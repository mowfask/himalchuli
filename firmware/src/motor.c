#include "motor.h"

//Current state of outputs:
//0:    low
//1:    high
//2:    pwm
uint8_t M1_state;
uint8_t M2_state;

void motor_init()
{
    //Motors as outputs
    setbit(DDR_M1H, DDM1H);
    setbit(DDR_M1L, DDM1L);
    setbit(DDR_M2H, DDM2H);
    setbit(DDR_M2L, DDM2L);

    setbit(PORT_M1L, PM1L);     //Mosfet on
    clearbit(PORT_M1H, PM1H);   //Mosfet off
    M1_state = 0;

    setbit(PORT_M2L, PM2L);     //Mosfet on
    clearbit(PORT_M2H, PM2H);   //Mosfet off
    M2_state = 0;

    //Timer1 preparation
    //We'll only use the low bits later
    OCR1AH = 0;
    OCR1BH = 0;

    //The timer should start at 0, else we'll wait forever on the first run
    TCNT1 = 0;
}

void M1_low()
{
    if(M1_state == 2)   //This shouldn't work in pwm mode
    {
        return;
    }
    //Set upper connector to 0 volts
    //First: make sure it's not set to 12V
    clearbit(PORT_M1H, PM1H);
    //Wait for the mosfet to block
    _delay_us(50);
    //Then connect it to ground
    setbit(PORT_M1L, PM1L);
    M1_state = 0;
}

void M1_high()
{
    if(M1_state == 2)   //This shouldn't work in pwm mode
    {
        return;
    }
    //Set upper connector to 12 volts
    //First: make sure it's not set to GND
    clearbit(PORT_M1L, PM1L);
    //Wait for the mosfet to block
    _delay_us(50);
    //Then connect it to 12V
    setbit(PORT_M1H, PM1H);
    M1_state = 1;
}

void M1_toggle()
{
    if(M1_state == 1)
    {
        M1_low();
    }
    else if(M1_state == 0)
    {
        M1_high();
    }
    //don't toggle if in pwm mode
}

void M2_low()
{
    if(M1_state == 2)   //This shouldn't work in pwm mode
    {
        return;
    }
    //Set lower connector to 0 volts
    //First: make sure it's not set to 12V
    clearbit(PORT_M2H, PM2H);
    //Wait for the mosfet to block
    _delay_us(50);
    //Then connect it to ground
    setbit(PORT_M2L, PM2L);
    M2_state = 0;
}

void M2_high()
{
    if(M1_state == 2)   //This shouldn't work in pwm mode
    {
        return;
    }
    //Set lower connector to 12 volts
    //First: make sure it's not set to GND
    clearbit(PORT_M2L, PM2L);
    //Wait for the mosfet to block
    _delay_us(50);
    //Then connect it to 12V
    setbit(PORT_M2H, PM2H);
    M2_state = 1;
}

void M2_toggle()
{
    if(M2_state == 1)
    {
        M2_low();
    }
    else if(M2_state == 0)
    {
        M2_high();
    }
    //don't toggle if in pwm mode
}

void motor_left()
{
    M2_low();
    _delay_ms(40);
    M1_high();
}

void motor_right()
{
    M1_low();
    _delay_ms(40);
    M2_high();
}

void motor_stop()
{
    M1_low();
    M2_low();
}

void motor_pwm_stop()
/*Disable pwm output on OC1A and OC1B pins and set the output to sane values.
 */
{
    clearmask(TCCR1A, COM1A1 | COM1A0 | COM1B1 | COM1B0);
    M1_low();
    M2_low();
}

void motor_pwm_start(uint8_t direction, uint8_t duty)
/*Set up pwm for the given direction (right: 0; left: non-0), with the given
 *duty (min: 0; max:255).
 *
 *We have to use timer/counter 1, as the pins we use are OC1A and OC1B.
 *We use phase correct pwm with a resolution of 8 bits, which should be more
 *than enough.
 *The PWM frequency should be somewhere around 20kHz. -> Even with a prescaler
 *of 1, the PWM freqency will be around 2kHz for phase correct PWM.
 */
{
    /*Waveform generation mode: 1 (phase correct 8-bit resolution)
     *WGM13:    0
     *WGM12:    0
     *WGM11:    0
     *WGM10:    1
     */
    setbit(TCCR1A, WGM10);
    clearbit(TCCR1A, WGM11);
    clearmask(TCCR1B, WGM12 | WGM13);

    motor_pwm_stop();
    _delay_ms(40);

    //we just set both compare registers, so we don't have to worry
    OCR1AL = duty;
    OCR1BL = duty;

    //Start the timer/counter by selecting the clock source (prescaler: 1)
    clearmask(TCCR1B, CS12 | CS11);
    setbit(TCCR1B, CS10);

    /*For enabling the actual pwm, from the datasheet:
     *Setting the COM1x1:0 bits to 2 will produce a non-inverted PWM and an
     *inverted PWM output can be generated by setting the COM1x1:0 to 3
     */

    if(direction)   //turn left
    {
        //M2 stays low, M1 pwm-toggles between high and not connected.
        M1_high();
        //for M1, we need to toggle PB2 -> OC1B
        clearbit(TCCR1A, COM1B0);
        setbit(TCCR1A, COM1B1);
        M1_state = 2;
    }
    else    //turn right
    {
        //M1 stays low, M2 pwm-toggles between high and not connected.
        M2_high();
        //for M2, we need to toggle PB1 -> OC1A
        clearbit(TCCR1A, COM1A0);
        setbit(TCCR1A, COM1A1);
        M2_state = 2;
    }
}

inline void motor_pwm_set(uint8_t duty)
/*Change the pwm value, assuming motor_pwm_start() has been run before.
 */
{
    //We just set both compare registers, the unused one doesn't matter.
    OCR1AL = duty;
    OCR1BL = duty;
}
